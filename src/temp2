#include <ros/ros.h>
#include <image_transport/image_transport.h>
#include <cv_bridge/cv_bridge.h>
#include <sensor_msgs/image_encodings.h>
#include <sensor_msgs/Image.h>
#include <cv.h>
#include <highgui.h>
#include <cxcore.h>
#include <cvaux.h>
#include <string.h>
#include <opencv2/highgui/highgui.hpp>
#include <opencv2/objdetect/objdetect.hpp>
#include <vector>
#include <stdlib.h>

using namespace cv;
using namespace std;

#define SAVE_EIGENFACE_IMAGES 1

void learn(char *szFileTrain);
void doPCA();
void storeTrainingData();
void storeEigenfaceImages();
int  loadTrainingData(CvMat ** pTrainPersonNumMat);
int  findNearestNeighbor(float * projectedTestFace);
int findNearestNeighbor(float * projectedTestFace, float *pConfidence);
int  loadFaceImgArray(char * filename);
void recognizeFileList(char *szFileTest);
void recognizeFromCam(void);


IplImage ** faceImgArr        = 0; // array of face images
CvMat    *  personNumTruthMat = 0; // array of person numbers
int faceWidth = 120;    // Default dimensions for faces in the face recognition database. Added by Shervin.
int faceHeight = 90;    //      "               "               "               "               "               "               "               "
int nPersons                  = 0; // the number of people in the training set. Added by Shervin.
int nTrainFaces               = 0; // the number of training images
int nEigens                   = 0; // the number of eigenvalues
IplImage * pAvgTrainImg       = 0; // the average image
IplImage ** eigenVectArr      = 0; // eigenvectors
CvMat * eigenValMat           = 0; // eigenvalues
CvMat * projectedTrainFaceMat = 0; // projected training faces
CvCapture* camera = 0;  // The camera device.

IplImage* convertFloatImageToUcharImage(const IplImage *srcImg)
{
        IplImage *dstImg = 0;
        if ((srcImg) && (srcImg->width > 0 && srcImg->height > 0)) {

                // Spread the 32bit floating point pixels to fit within 8bit pixel range.
                double minVal, maxVal;
                cvMinMaxLoc(srcImg, &minVal, &maxVal);

                //cout << "FloatImage:(minV=" << minVal << ", maxV=" << maxVal << ")." << endl;

                // Deal with NaN and extreme values, since the DFT seems to give some NaN results.
                if (cvIsNaN(minVal) || minVal < -1e30)
                        minVal = -1e30;
                if (cvIsNaN(maxVal) || maxVal > 1e30)
                        maxVal = 1e30;
                if (maxVal-minVal == 0.0f)
                        maxVal = minVal + 0.001;        // remove potential divide by zero errors.

                // Convert the format
                dstImg = cvCreateImage(cvSize(srcImg->width, srcImg->height), 8, 1);
                cvConvertScale(srcImg, dstImg, 255.0 / (maxVal - minVal), - minVal * 255.0 / (maxVal-minVal));
        }
        return dstImg;
}

// Read the names & image filenames of people from a text file, and load all those images listed.
int loadFaceImgArray()
{
        char imgFilename[512];
        int iFace, nFaces=50;
        int i;

       // allocate the face-image array and person number matrix
        faceImgArr        = (IplImage **)cvAlloc( nFaces*sizeof(IplImage *) );
        personNumTruthMat = cvCreateMat( 1, nFaces, CV_32SC1 );

        // store the face images in an array
        for(iFace=0; iFace<nFaces; iFace++)
        {
                // load the face image
                char s[100];
                sprintf(s,"../data/%s_%d.pgm","pond",iFace);
                printf("%s\n",s);
                faceImgArr[iFace] = cvLoadImage(s, CV_LOAD_IMAGE_GRAYSCALE);

                if( !faceImgArr[iFace] )
                {
                        fprintf(stderr, "Can\'t load image from %s\n", imgFilename);
                        return 0;
                }
        }
        return nFaces;
}
void doPCA()
{
        int i;
        CvTermCriteria calcLimit;
        CvSize faceImgSize;

        // set the number of eigenvalues to use
        nEigens = nTrainFaces-1;

        // allocate the eigenvector images
        faceImgSize.width  = faceImgArr[0]->width;
        faceImgSize.height = faceImgArr[0]->height;
        eigenVectArr = (IplImage**)cvAlloc(sizeof(IplImage*) * nEigens);
        for(i=0; i<nEigens; i++)
                eigenVectArr[i] = cvCreateImage(faceImgSize, IPL_DEPTH_32F, 1);

        // allocate the eigenvalue array
        eigenValMat = cvCreateMat( 1, nEigens, CV_32FC1 );

        // allocate the averaged image
        pAvgTrainImg = cvCreateImage(faceImgSize, IPL_DEPTH_32F, 1);

        // set the PCA termination criterion
        calcLimit = cvTermCriteria( CV_TERMCRIT_ITER, nEigens, 1);

        // compute average image, eigenvalues, and eigenvectors
        cvCalcEigenObjects(
                0,
                (void*)faceImgArr,
                (void*)eigenVectArr,
                CV_EIGOBJ_NO_CALLBACK,
                0,
                0,
                &calcLimit,
                pAvgTrainImg,
                eigenValMat->data.fl);

        cvNormalize(eigenValMat, eigenValMat, 1, 0, CV_L1, 0);
}
void learn(char *szFileTrain)
{
        int i, offset;
/*
        // load training data
        printf("Loading the training images in '%s'\n", szFileTrain);
        nTrainFaces = loadFaceImgArray(szFileTrain);
        printf("Got %d training images.\n", nTrainFaces);
        if( nTrainFaces < 2 )
        {
                fprintf(stderr,
                        "Need 2 or more training faces\n"
                        "Input file contains only %d\n", nTrainFaces);
                return;
        }
        */
        // do PCA on the training faces

        nTrainFaces = loadFaceImgArray();
        doPCA();
        printf("1");
        // project the training images onto the PCA subspace
        projectedTrainFaceMat = cvCreateMat( nTrainFaces, nEigens, CV_32FC1 );
        offset = projectedTrainFaceMat->step / sizeof(float);
        for(i=0; i<nTrainFaces; i++)
        {
                //int offset = i * nEigens;
                cvEigenDecomposite(
                        faceImgArr[i],
                        nEigens,
                        eigenVectArr,
                        0, 0,
                        pAvgTrainImg,
                        //projectedTrainFaceMat->data.fl + i*nEigens);
                        projectedTrainFaceMat->data.fl + i*offset);
        }

        // store the recognition data as an xml file
        storeTrainingData();

        // Save all the eigenvectors as images, so that they can be checked.
        if (SAVE_EIGENFACE_IMAGES) {
                storeEigenfaceImages();
        }

}

void storeTrainingData()
{
        CvFileStorage * fileStorage;
        int i;

        // create a file-storage interface
        fileStorage = cvOpenFileStorage( "facedata.xml", 0, CV_STORAGE_WRITE );

        // Store the person names. Added by Shervin.
        cvWriteInt( fileStorage, "nPersons", 49 );
        for (i=0; i<nPersons; i++) {
                char varname[200];
                sprintf( varname, "personName_%d", (i+1) );
                cvWriteString(fileStorage, varname, "pond", 0);
        }

        // store all the data
        cvWriteInt( fileStorage, "nEigens", nEigens );
        cvWriteInt( fileStorage, "nTrainFaces", nTrainFaces );
        cvWrite(fileStorage, "trainPersonNumMat", personNumTruthMat, cvAttrList(0,0));
        cvWrite(fileStorage, "eigenValMat", eigenValMat, cvAttrList(0,0));
        cvWrite(fileStorage, "projectedTrainFaceMat", projectedTrainFaceMat, cvAttrList(0,0));
        cvWrite(fileStorage, "avgTrainImg", pAvgTrainImg, cvAttrList(0,0));
        for(i=0; i<nEigens; i++)
        {
                char varname[200];
                sprintf( varname, "eigenVect_%d", i );
                cvWrite(fileStorage, varname, eigenVectArr[i], cvAttrList(0,0));
        }

        // release the file-storage interface
        cvReleaseFileStorage( &fileStorage );
}
void storeEigenfaceImages()
{
        // Store the average image to a file
        printf("Saving the image of the average face as 'out_averageImage.bmp'.\n");
        cvSaveImage("out_averageImage.bmp", pAvgTrainImg);
        // Create a large image made of many eigenface images.
        // Must also convert each eigenface image to a normal 8-bit UCHAR image instead of a 32-bit float image.
        printf("Saving the %d eigenvector images as 'out_eigenfaces.bmp'\n", nEigens);
        if (nEigens > 0) {
                // Put all the eigenfaces next to each other.
                int COLUMNS = 8;        // Put upto 8 images on a row.
                int nCols = min(nEigens, COLUMNS);
                int nRows = 1 + (nEigens / COLUMNS);    // Put the rest on new rows.
                int w = eigenVectArr[0]->width;
                int h = eigenVectArr[0]->height;
                CvSize size;
                size = cvSize(nCols * w, nRows * h);
                IplImage *bigImg = cvCreateImage(size, IPL_DEPTH_8U, 1);        // 8-bit Greyscale UCHAR image
                for (int i=0; i<nEigens; i++) {
                        // Get the eigenface image.
                        IplImage *byteImg = convertFloatImageToUcharImage(eigenVectArr[i]);
                        // Paste it into the correct position.
                        int x = w * (i % COLUMNS);
                        int y = h * (i / COLUMNS);
                        CvRect ROI = cvRect(x, y, w, h);
                        cvSetImageROI(bigImg, ROI);
                        cvCopyImage(byteImg, bigImg);
                        cvResetImageROI(bigImg);
                        cvReleaseImage(&byteImg);
                }
                cvSaveImage("out_eigenfaces.bmp", bigImg);
                cvReleaseImage(&bigImg);
        }
}



int main()
{
  IplImage* img;
  IplImage * a, *b;
  //cvMat *a,*b;

  learn("pond");
  storeTrainingData();
  int i =0;
  while(1)
  {
    cvShowImage("test",faceImgArr[i++]);
    //cvShowImage("test",&projectedTrainFaceMat);
    char ch = cvWaitKey(500);
    if(ch==27) break;
    if(i>49) i =0;
    printf("%d\n",i);
  }

  cvReleaseImage(&img);
  cvDestroyWindow("test");
}
/*

*/
